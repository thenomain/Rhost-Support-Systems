/*
STARTMUSH FUNCTIONS, RHOST EDITION

May or may not be fully tested yet.


================================================================================
== SETTING UP EXECSCRIPT =======================================================

@power/councilor me=execscript
@set me=sidefx

macOS: ln -s /usr/local/bin/gtimeout /path/to/Server/bin/timeout
(still doesn't work in macOS, but they know)


================================================================================
== User-Defined Functions <udf> ================================================

A set of functions that can (or in some cases will) be useful on nearly any 
game. Designed for TinyMUX.


--------------------------------------------------------------------------------
-- Setup -----------------------------------------------------------------------

If your game setup does not give '@function' access to wizard, change the below 
to work with your game.

I'M USING @TAG FOR THE FIRST TIME EVER. I HOPE IT WORKS.

If you used the default SGP installation, the following will be true, 
else fix it:
    #3 is the Storage Wizard

*/

@create User-Defined Functions <udf>=10
@tag/add UDF=User-Defined Functions <udf>

// Set the UDF dbref on yourself
@force me=&d.udf me=[search( object=User-Defined Functions <udf> )]

// If you're using SGP, Storage Wizard is #3:
@force me=&d.udf #3=[search( object=User-Defined Functions <udf> )]
@chown User-Defined Functions <udf>=#3
@set User-Defined Functions <udf>=inherit !halt safe

@startup [v( d.udf )]=
    @dolist lattr( %!/ufunc.* )={ 
        @function/preserve [rest( ##, . )]=%!/##
    }; 

    @dolist lattr( %!/ufunc/privileged.* )={ 
        @function/privileged/preserve [rest( ##, . )]=%!/##
    }; 


/*
--------------------------------------------------------------------------------
-- Replacement Width() ---------------------------------------------------------

RHOST doesn't do NAWS from Telnet, so let's find people's width.

*/

&UFUNC/PRIVILEGED.WIDTH [v( d.udf )]=
    strcat( 
        setq( 0, if( t( %0 ), %0, %# )), 
        if( cor( isstaff( %@ ), haspower( %@, see_all ), strmatch( %#, %q0 )), 
            strcat( 
                setq( u, get( %q0/width )), 
                setq( w, 79 ), 
                case( 1, 
                    cand( isint( %qu ), gt( %qu, 0 )), %qu, 
                    eq( %qw, 78 ), 79,  
                    %qw 
                )
            ), 
            #-1 Permission Denied 
        )
    )
&HELP.WIDTH [v( d.udf )]=
    width( [<target>] ): 
    Allows players to set '&width' on themselves to force a non-80-character 
    width.


/*
--------------------------------------------------------------------------------
-- Cross-Platform Compatibility ------------------------------------------------

It might be strange to see this in the "Rhost Starter Code", but I would like 
this code to be starter code for multiple platforms, as it would make it easier 
for installers and for me to port code.

*/

// rhost: @@(), else: @@ 
@switch/first version()=
	RhostMUSH*, { &.null [v( d.udf )]=lit(@@( )) }, 
	{ &.null [v( d.udf )]=@@ }

// rhost: mwords(), else: words()
@switch/first version()=
	RhostMUSH*, { &.words [v( d.udf )]=lit(mwords( %0, %1 )) }, 
	{ &.words [v( d.udf )]=lit(words( %0, %1 )) }


/*
--------------------------------------------------------------------------------
-- Critical Functions ----------------------------------------------------------

Don't make your game without these.
(Author's opinion; results may vary; see your doctor)

*/


&UFUNC.HEADER [v( d.udf )]=
	printf( 
		$^
			[if( cand( isint( %1 ), gt( %1, 1 )), %1, 79 )]
			:[ansi( c, %<058> )]:
		s, 
		ansi( c, ., h, %b %0 %b, c, . )
	)
&HELP.HEADER [v( d.udf )]=
    header( <text> ): 
    A game-wide output header.



// - : left justify
&UFUNC.DIVIDER [v( d.udf )]=
	printf( 
		$-
			[if( cand( isint( %1 ), gt( %1, 1 )), %1, 79 )]
			:[ansi( c, . )]:
		s, 
		if( strlen( %0 ),
			ansi( c, ..:, h, %b %0 %b, c, : )
		)
	)
&HELP.DIVIDER [v( d.udf )]=
    divider( [<text>] ): 
    A game-wide output divider.




// right justify by default
&UFUNC.FOOTER [v( d.udf )]=
	printf( 
		$
			[if( cand( isint( %1 ), gt( %1, 1 )), %1, 79 )]
			:[ansi( c, %<058> )]:
		s, 
		if( strlen( %0 ),
			ansi( c, ., h, %b %0 %b, c, .:: )
		)
	)
&HELP.FOOTER [v( d.udf )]=
    footer( [<text>] ): 
    A game-wide output footer.




&UFUNC.WHEADER [v( d.udf )]=header( %0, width( %# ))
&HELP.WHEADER [v( d.udf )]=
    wheader( <text> ): 
    A game-wide output header as wide as the user's screen.

&UFUNC.WDIVIDER [v( d.udf )]=divider( %0, width( %# ))
&HELP.WDIVIDER [v( d.udf )]=
    wdivider( [<text>] ): 
    A game-wide output divider as wide as the user's screen.

&UFUNC.WFOOTER [v( d.udf )]=footer( %0, width( %# ))
&HELP.WFOOTER [v( d.udf )]=
    wfooter( [<text>] ): 
    A game-wide output footer as wide as the user's screen.

&UFUNC.MSG [v( d.udf )]=ansi( h, <%0>, n, %b%1 )
&HELP.MSG [v( d.udf )]=
    msg( <header>, <message> ): 
    A game-wide notice output.



// TITLESTR!!!!

&UFUNC.TITLESTR [v( d.udf )]=
    iter( 
        lcstr( %0 ), 
        case( 1, 
            t( 
                regmatch( 
                    %i0, 
                    u( #UDF/d.titlestr-regexp )
                )
            ), 
            %i0, 

            t( 
                setr( e, 
                    grab( 
                        u( #UDF/d.titlestr-punctuation ), 
                        escape( right( %i0, 1 ))
                    )
                )
            ), 
            [ulocal( #UDF/ufunc.titlestr, 
                strtrunc( %i0, dec( strlen( %i0 ))), 
                %1 
            )]
            %qe, 

            t( 
                setr( e, 
                    grab( 
                        [u( #UDF/d.titlestr-exception )] 
                        %1, 
                        %i0 
                    )
                )
            ), 
            %qe, 

            cand( 
                t( 
                    match( 
                        u( #UDF/d.titlestr-notitle ), 
                        %i0 
                    )
                ), 
                neq( inum( 0 ), 1 )
            ), 
            %i0, 

            t( 
                setr( e, 
                    grab( 
                        u( #UDF/d.titlestr-punctuation ), 
                        escape( strtrunc( %i0, 1 ))
                    )
                )
            ), 
            %qe
            [ulocal( #UDF/ufunc.titlestr, 
                rest( %i0, %qe ), 
                %1 
            )], 

            capstr( %i0 )
        )
    )
&HELP.TITLESTR [v( d.udf )]=
    titlestr( <string>[, <words to ignore>] ): 
    Outputs text in a 'title string' format, 
    will output <words to ignore> exactly as they are entered.

&D.TITLESTR-NOTITLE [v( d.udf )]=
    a an the at by for in of on to up and as but it or nor

&D.TITLESTR-PUNCTUATION [v( d.udf )]=
    . , ? ! ; : ( ) < > { } * / - + " '

&D.TITLESTR-REGEXP [v( d.udf )]=
    \[^[escape( u( d_titlestr-punctuation ))]\].*\\(.*\\)

&D.TITLESTR-EXCEPTION [v( d.udf )]=
    iPod von BBS OOC IC EOD XP UFO DIY EMT FBI ASL EPD EMTs EU DJs TV VIP A&P 
    NPC DVD VCR PT

&UFUNC.LMAX [v( d.udf )]=last( sort( %0, n, %1, %1 ), %1 )
&HELP.LMAX [v( d.udf )]=
    lmax( <list of numbers>[, <delimiter>] ): 
    Highest number in delimited list.

&UFUNC.LMIN [v( d.udf )]=first( sort( %0, n, %1, %1 ), %1 )
&HELP.LMIN [v( d.udf )]=
    lmin( <list of numbers>[, <delimiter>] ): 
    Lowest number in delimited list.

// The next two are "critical" for games geared toward RPG systems

&UFUNC/PRIVILEGED.ISIC [v( d.udf )]=t( get( %0/_ic ))
&HELP.ISIC [v( d.udf )]=
    isic( <target> ): 
    Returns '1' if target is in a room marked 'in-character'.

&UFUNC/PRIVILEGED.SHORTDESC [v( d.udf )]=
    case( 1, 
        cand( 
            hasattr( 
                setr( 0, 
                    case( %0, 
                        me, %#, 
                        here, loc( %# ), 
                        pmatch( %0 )
                    )
                ), 
                short-mien 
            ), 
            hastxlevel( %q0, HEDGE ), 
            cor( 
                hasrxlevel( %#, HEDGE ), 
                hasrxlevel( %#, ALL ), 
                strmatch( parent( room( %# )), << hedge parent >> )
            )
        ), 
        < short-mien >, 

        hasattr( %q0, short-desc ), get( %q0/short-desc ), 

        match( %0, %# ), 
        ansi( xh, %(Use &short-desc me=text to set this%) ), 

        @@( show nothing - %q0 - %# )
    )
&HELP.SHORTDESC [v( d.udf )]=
    shortdesc( <target> ): 
    Shows the most appropriate '&short-desc' attribute the viewer can see. 
    (Some holding code in there for reality levels.)


/*
--------------------------------------------------------------------------------
-- Vcolumns --------------------------------------------------------------------

Two ways to display information vertically.
    vcolums() -- Thenomain
    vtable()  -- Chime

(These should be rewritten if/when printf() handles UTF-8.)

--

vcolumns( <width1>:<list1>, ..., <delim>, <divider>, <left>, <right> )

e.g.:
think vcolumns( 14:this`is`a`really kind of annoying test bla, 10:, `, %b|%b )


Due to limitations in Mu* code, the only way to separate <width> from <list> 
is with a pre-defined delimiter for this only. I'm sticking with :.

Max columns is 9, 8 if delim, 7 if divider, 6 if left, 5 if right.

--

Here's some fun tests:

think vcolumns( 5:this is an test, 20:this is another test that we're going to test things out on, , | )

think vcolumns( 5:this`````is a test, 20:this`is another test that we're going to test things out`on, `, %b|%b )
--

input:

	0-9: input, hopefully at least one columns

registers:
	0-9: columns
	d: delimiter
	i: divider character(s)
	l: left character(s)
	r: right character(s)

	c: number of columns
	h: height

*/

&UFUNC.VCOLUMNS [v( d.udf )]=
//.. it's possible to have no properly defined columns, so error out then
	if( 
		not( cand( 
			strmatch( %0, *:* ), 
			isint( before( %0, : ))
		)), 
		#-1 MUST START WITH ONE VALID COLUMN, 

//.. continue
		strcat( 
//.. this next section determines how many arguments are column definitions
//.. 9 registers only - %0 to %9
			iter( lnum( 9 ), 
				if( 
//.. c: if %<num> is "<width>:*", # of columns = <num>+1
					cand( 
						isint( before( v( %i0 ), : )), 
						strmatch( v( %i0 ), *:* )
					), 
					setq( c, inc( %i0 ))
				), 
				, u(#UDF/.null)
			), 
/*
    at this this point, %qc will be 1 to 9
    which will be the 'next' argument, since arguments are 0-offset
    so for vcolumns( 10:test, 10:another test, , | )
    "10:test" is '%0' and has 1 column
    "10:another" test is '%1' and has 2 columns
    delimiter would be in '%2', which is also the number of columns
    so delimiter would always be set at 'v( %qc )'
*/

//.. d: delimiter, v: column seperator, l: left, r: right
			setq( d, if( comp( v( %qc ), ), v( %qc ))), 
			setq( v, v( inc( %qc ))), 
			setq( l, v( add( %qc, 2 ))), 
			setq( r, v( add( %qc, 3 ))), 

//.. for each column .. q0-q9: <width>:<formatted text>, w: width
			iter( lnum( %qc ), 
				setq( %i0, 
					[setr( w, first( v( %i0 ), : ))]:
					[wrap( edit( rest( v( %i0 ), : ), %qd, %r ), %qw, left )] 
				), 
				, u(#UDF/.null)
			), 

//.. h: height of the tallest column
			iter( lnum( %qc ), 
				setq( h, 
					max( %qh, u( #UDF/.words, rest( r( %i0 ), : ), %r ))
				), 
				, u(#UDF/.null) 
			), 

//.. 'from 1 to height do:'
			iter( lnum( 1, %qh ), 
//.. (left decoration)
				%ql
//.. 'for each column do:'
				[iter( lnum( %qc ), 
//.. if current column has something in it, display that
					if( 
						strlen( 
							setr( z, 
								elements( 
									rest( r( %i0 ), : ), 
									inum(1),           // what row are we on?
									mid( %r, 1, 1 )    // strip CR from CRLF
								)
							)
						), 
						%qz, 
//.. else, put as many spaces as column width
						space( first( r( %i0 ), : ))
					), 
//.. (between-column decoration)
					, %qv 
				)]
//.. (right decoration)
				%qr, 
				, %r 
			)
		)
	)

&HELP.VCOLUMNS [v( d.udf )]=See in-depth help file.

/*
VCOLUMNS HELP

vcolumns() creates vertical columns of text with a specified width for each.

USAGE:
    vcolumns(
        <width 1>:<text 1>
        [..., <width n>:<text n>]
        [, <delimiter>
        [, <divider char(s)>
        [, <left char(s)>
        [, <right char(s)>]]]]
    )

e.g.
    vcolumns( 14:this`is`a`a test for how this works etc etc, 10:, `, %b|%b )

It may also have optional ornamentation of any or all of the following: between each column, on the left of each line, on the right of each line.

These options are positional, meaning if you choose to have any of the following, you must at least leave an empty option for any that come before it. 

    <delimiter>       : Creates a newline break within that column.
    <divider char(s)> : Character(s) between columns.
    <left char(s)>    : Character(s) to the left of each line.
    <right char(s)>   : Character(s) to the right of each line.

e.g., using the divider decoration but without a delimiter:
    vcolumns( 14:let's make this column a bunch of text here, 10:, , %b|%b )

LIMITATIONS:
* vcolumns() can only take up to 9 arguments, even if you are using delimiter or 
  decorations.
* This means you can have at most 5 columns if you're using the <right char(s)>
  decoration.

*/


/*
--------------------------------------------------------------------------------
-- Vtable ----------------------------------------------------------------------

Two ways to display information vertically.
    vcolums() -- Thenomain
    vtable()  -- Chime

(These should be rewritten if/when printf() handles UTF-8.)

--

	vtable( <items to display>, ???? )

vtable() is like vcolumns() but it automatically calculates the best width to make sure every column in the table is the same, across the total width of the player's screen as reported by width().

e.g.
	think vtable( this_is a pretty_decent_test to have for this )


d: delimiter (defaults 'space')
c: count of words

*/

&UFUNC.VTABLE [v( d.udf )]=
    strcat( 
        setq( d, if( strlen( %2 ), %2, %b )), 
        setq( c, words( %0, %qd )), 
        setq( x, 
        	max( 1, 
        		min( 
        			%qc, 
        			if( %1, %1, %qc ), 
        			div( width( %# ), 2 ), 
        			div( inc( width( %# )), 
        				last( 
        					sort( 
        						iter( %0, 
        							inc( strlen( %i0 )), 
        							%qd, %b 
        						)
        					)
        				)
        			)
        		)
        	)
        ), 
        setq( y, div( add( %qc, dec( %qx )), %qx )), 
        setq( x, div( add( %qc, dec( %qy )), %qy )), 
        setq( w, widthcol( %qx )), 
        setq( p, if( strlen( %4 ), %4, %b )), 
        setq( s, if( strlen( %3 ), %3, %b )), 
        if( %qc, 
            iter( transpose( %qx, %qy ), 
                strcat( 
                    ljust( index( %0, %qd, %i0, 1 ), %qw, %qp ), 
                    switch( 1, 
                        t( mod( inum( 0 ), %qx )), 
                        rjust( 
                            %qs, 
                            slackcol( %qx, inc( mod( inum( 0 ), %qx )))
                        ), 
                        lt( inum( 0 ), %qc ), 
                        %r 
                    )
                ), 
                %b, @@() 
            )
        )
    )
&HELP.VTABLE [v( d.udf )]=See in-depth help file.

/*
VTABLE HELP

There should be a complex vcolumns help.

I use this for my Code Object Data Parent.

*/

&UFUNC.TRANSPOSE [v( d.udf )]=
    iter( 
        lnum( 0, dec( %1 )), 
        iter( lnum( 0, dec( mul( %0, %1 )), , %1 ), add( 1, %i0, %i1 ))
    )
&HELP.TRANSPOSE [v( d.udf )]=See in-depth help file.

&UFUNC.SLACKCOL [v( d.udf )]=
    strcat( 
        setq( s, sub( width( %# ), mul( widthcol( %0 ), %0 ))), 
        sub( 
            div( mul( %qs, %1 ), dec( %0 )), 
            div( mul( %qs, dec( %1 )), dec( %0 ))
        )
    )
&HELP.SLACKCOL [v( d.udf )]=See in-depth help file.

&UFUNC.WIDTHCOL [v( d.udf )]=
    if( lt( %0, 2 ), 
        width( %# ), 
        floor( fdiv( sub( width( %# ), sub( %0, 1 )), %0 ))
    )
&HELP.WIDTHCOL [v( d.udf )]=See in-depth help file.

/*
--------------------------------------------------------------------------------
-- Other Nicities --------------------------------------------------------------
*/

&UFUNC.CRUMPLE [v( d.udf )]=trim( squish( %0, %1 ), b, %1 )
&HELP.CRUMPLE [v( d.udf )]=
    crumple( <list of items>[, <delimiter>] ): 
    Removes multiple delimiters from middle, start, and end. 
    e.g., thing1|thing2|||thing4| -> thing1|thing2|thing4


// man I hope this works
&UFUNC.LNUMRANGES [v( d.udf )]=
	iter( %0, 
		case( 1, 
			regmatch( %i0, get( #UDF/regexp.lnumranges ), 0 1 2 ),
			lnum( %q1, %q2 ), 
			%i0 
		)
	)

&REGEXP.LNUMRANGES [v( d.udf )]=(-?\d+)-(-?\d+)

&HELP.LNUMRANGES [v( d.udf )]=
    lnumranges( <list of numbers or num-ranges> ): 
    Returns the input list, expanding n1-n2 number ranges. 
    e.g., lnumranges( 4 f-15 10-15 -9--12 1 6 blar 2 )
//  (Thanks Myrddin and Ambrosia!)


// -- PLURAL -------------------------------------------------------------------

&UFUNC.PLURAL [v( d.udf )]=
    if( isint( %0 ), 
        if( strlen( %2 ), 
            if( eq( %0, 1 ), %1, %2 ), 
            if( eq( %0, 1 ), %1, %1s )
        ), 
        if( strlen( %2 ), 
            if( eq( words( %0 ), 1 ), %1, %2 ), 
            if( eq( words( %0 ), 1 ), %1, %1s )
        )
    )
&HELP.PLURAL [v( d.udf )]=
    plural( <num>, <singular>, <plural> ): 
    Outputs <num> plus the <singular> or <plural> as passed.
    Looks like it might be able to handle 'plural( <list of things>, ... )'.

// RHOST: moniker() -> cname()
&UFUNC.SAY [v( d.udf )]=
    strcat( 
        setq( 0, regmatchi( %1, %(.%)%(%[\\s\\S%]*%), 0 1 2 )), 
        switch( %q1, 
            :, [cname( %0 )] %q2, 
            ;, [cname( %0 )]%q2, 
            |, %q2, 
            ", [cname( %0 )] says%, “%q2”, 
            [cname( %0 )] says%, “%q1%q2” 
        )
    )
&HELP.SAY [v( d.udf )]=
    say( <say or pose format> ): 
    Outputs the same as say/pose/emit.


// I Can't Remember and apparently doesn't work anyway

/*
&UFUNC.LPMATCH [v( d.udf )]=
    [setq( e, 
        case( 1, 
            cor( not( strlen( %0 )), strlen( %3 )), 
            #-1 FUNCTION (LPMATCH) EXPECTS BETWEEN 1 AND 3 ARGUMENTS, 
            strmatch( %1, ), #-1 NO ZERO WIDTH DELIMITERS, 
            gte( strlen( %1 ), 5 ), #-1 DELIMITER TOO LONG, 
            not( match( |allow|deny, %2*, | )), #-1 ERROR TYPE NOT FOUND, 
            strmatch( %1, " ), 
            squish( trim( iter( %0, if( mod( inum( 0 ), 2 ), iter( %i0, if( setr( p, pmatch( %i0 )), %qp, #-1 %i0 ), , | ), if( setr( p, pmatch( %i0 )), %qp, #-1 %i0 )), ", | ), b, | ), | ), 
            iter( %0, 
                if( setr( p, pmatch( trim( %i0 ))), 
                    %qp, 
                    #-1 [trim( %i0 )] 
                ), 
                %1, | 
            )
        )
    )]
    [switch( 1, 
        not( t( %qe )), %qe, 
        cand( strmatch( %qe, *#-1* ), strmatch( %2, d* )), 
        #-1 NOT FOUND|[iter( graball( %qe, #-1 *, | ), rest( %i0 ), |, | )], 
        %qe 
    )]
&HELP.LPMATCH [v( d.udf )]=
    lpmatch( ??? ): 
    A way to turn a list of player names into player dbrefs.
*/

/*
--------------------------------------------------------------------------------
-- Finalize --------------------------------------------------------------------
*/

@switch/first version()=
	RhostMUSH*, { @@ do nothing }, 
	{ @fo me=@edit [v( d.udf )]/*=#UDF, [v( d.udf )] }

@trigger v( d.udf )/startup

// The Code Object Data Parent, if you're using it.
@force me=@parent [v( d.udf )]=
    [search( object=Code Object Data Parent <codp> )]

